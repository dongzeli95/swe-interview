# Design Inventory

System Design：不是最常见的visa payment system, 而是inventory management, 设计当有客户，卖菜人，和买菜人同时需要更新菜的数量和买卖的情况。全程面试官毫无交流，感觉对墙说话。我每五分钟都停下来确认是不是再聊他想讨论的内容，面试官都是一句敷衍带过good good。最后草草收场去开别的会了。。



shopping experience for customer

* retailer app check 库存 {商店, 商品, 薯量}
* customer app 架入 商品 {商店, 商品, 薯量，盯单}
* 跑腿小哥 checkout {商店, 商品, 薯量，盯单} 没什么特别好的想法，主要问了问库存怎么扣出‍‍‍‍‍‍‍‌‍‌‌‌‌‍‍‌‌‌，怎么确认不超存量

{% embed url="https://www.1point3acres.com/bbs/thread-1025963-1-1.html" %}

## Functional Requirement

1. Retailers are able to check inventory, add/update inventory, delete inventory...
2. Customers are able to check inventory, make an order on inventory.
3. Shopper can checkout on the order.

## Non-functional Requirement

1. Highly available
2. Highly scalable
3. Low latency
4. Consistency - if customer make an order, the items quatity need to be accurate?

## Scale

How much scale we are looking at? and read:write ratio?

75k stores, 500M products on the shelves.

2M active users place multiple orders of tens of items in their cart every month.

### Data

75k store, 500M items, 200 locations

> On average a user will make 20 searches per basket before they checkout.

500\*10^6 / (75\*10^3) = 500/75\*10^3 = 10^4 items per store.

1 store -> items

> Retailer partners update inventory once a day for availability of all items on instacart.

> Despite estimation about availability, purchased items are not reserved until our shoppers pick them up in the store.



## API

```
Retailer
CRUD -> Update

Customer
CRUD order
get product item

Shopper
Get order
Update order: Mark item as found
Update Item: Mark not found.
```

## Data Schema

```
User table
user_id

Shopper table

Store table
store_id
store_name
location

Stock table
item_id
store_id
quantity
created_at

Item table
item_id
category_name

Order table

Question:
how to quickly update quantity for each product item?
is it necessary to keep a separate table for stock quantity?
```

## Deep Dive

### How to show accurate item availability?

Ingesting scores generated by ML models into DB storage for fast and bulk retrieval. In both method, we store score in DB and update them to address low latency use cases.

1. Full sync

The ML availability scoring service updates a table multiple times a day in Snowflake with the refreshed availability score of items.  The DB ingestion workers read the snowflake table periodically and upsert the availability score for refreshed items to ensure no scores are stale.

2. Lazy Score Refresh

Scores are updated on demand based on an item appearing in the search results. The refresh activity happens in background jobs and used kinesis to aggregate the updates to DB.

<figure><img src="../../.gitbook/assets/Screenshot 2024-03-14 at 9.29.31 PM (1).png" alt=""><figcaption></figcaption></figure>

### Initial model for item availability

<figure><img src="../../.gitbook/assets/Screenshot 2024-03-14 at 9.33.06 PM.png" alt=""><figcaption></figcaption></figure>

### New Model

The new model combines three components for general, trending and real-time availability scores.&#x20;

* General Score: describes typical item availability patterns and is recalculated weekly.
* Trending Score: Quantifies short-term deciations from typical patterns and is recomputed daily or hourly.
* Real-time score: based on latest observations, use a event driven streaming achitecture that employs Kafka and Flink to deliver signals sourced from customer applications and retailer systems.

<figure><img src="../../.gitbook/assets/Screenshot 2024-03-14 at 9.39.33 PM.png" alt=""><figcaption></figcaption></figure>
